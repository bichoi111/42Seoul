1.  id : 사용자 정보, Gn : Groupname, tr " " "," : 공백문자를 ,로 바꾸겠다. 
	tr -d "\n" : ""안의 내용을 삭제(-d)하겠다.

2.  . : 현재 디렉토리와 하위디렉토리에 있는 모든 파일과 디렉토리
	-type f : 파일만 찾아라
	-name "*.sh" 이름이 *(와일드카드).sh 인
	-exec : find 명령어로 수행된 결과에서 다른 기능 수행할 때 쓰는 명령어
	basename : find로 찾으면 '/디렉토리/파일명.sh' 이런식으로 나오는데
			   이 명령어를 쓰면 디렉토리를 제외한 파일명만 추출한다.
	{} : find로 찾은 결과를 입력으로 받겠다.
	/; : exec명령어의 끝
	awk : 데이터를 조작하기 위한 명령어
	-F : 필드 구분자. 뒤에 나오는 패턴으로 필드를 구분하겠다.
	awk -F '.' '{print $1}' : '.'으로 필드를 구분하고, 1열만 출력.

3.  find . | wc -l | tr -d " " : 현재 디렉토리를 포함하여 하위디렉토리에서 
	모든 파일과 디렉토리를 찾을건데, wc(wordcount) count를 하겠다. 
	-l : line을 세겠다. 그리고 공백은 삭제(tr -d)한다.

4.  ifconfig : 네트워크 인터페이스 정보를 확인하거나 설정하는 명령어.
	-a : 비활성화된 네트워크 모두 표시
	grep : 특정 문자열을 찾을 건데, ether과 완전히 동일한(-w) 단어를 찾음.
	그리고 공백으로 구분되는 2열 출력

5.  echo -n 42 > : echo 화면에 텍스트를 출력하는 명령어. 
	-n : 개행문자(\n)를 제거한다. 이게 1바이트.
	> : 리다이렉션
	*특수문자 앞에 '/'붙여야 파일명에 특수문자 넣을 수 있음.

6.  ls -l
	awk '{if(NR%2==1)print}' : NR은 awk 명령어에서 지정되어있는 변수인데,
	레코드의 번호를 나타낸다. 즉 홀수행만 출력한다.
	맨 첫행은 total로 시작할 것!
	print : 전체 내용 출력.
	* if문 : '{if (condition) action}'

7.  sed : 원본을 변형시키지 않고 단지 출력결과를 변화시켜 보여주는 역할.
	sed '/^#/d' : #으로 시작하는 라인을 삭제(d)
	rev : 한 행의 내용을 거꾸로 출력하겠다.
	sort -r : 내림차순으로 정렬하겠다.
	sed -n "${FT_LINE1}, ${FT_LINE2}p" : -n은 특정행만 선택하는 옵션. 
										FT_LINE1부터 FT_LINE2까지의 행을 출력(p)
	tr '\n' ',' : \n을 ,로 바꾸겠다.
	sed 's/,/, /g' : s는 치환의 의미.','를 공백을 포함한 ', '바꿈.
	그리고 마지막에 cat -e 하면 ', $'로 끝나는데 문제에서 요구하는 '.'로 바꿈.
	또 출력하면 $가 붙어 나오는데 tr -d 로 제거하겠다.

8. xarges는 파이프의 입력을 받아오는 명령어.
   echo "obase=13; ibase=5;" | bc : 5진수를 13진수로 바꾸어 계산(bc)한다.
   여기까지 나온 결과는 13진수이니 이걸 문제에서 요구하는 "gt~"로 바꿈.

